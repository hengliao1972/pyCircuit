#include <cstdint>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <sstream>
#include <string>

#include <pyc/cpp/pyc_konata.hpp>
#include <pyc/cpp/pyc_tb.hpp>

// Generated by `pyc-compile --emit=cpp`.
#include "linx_cpu_pyc_gen.hpp"

using pyc::cpp::Testbench;
using pyc::cpp::Wire;

namespace {

constexpr std::uint64_t kBootPc = 0x0000'0000'0001'0000ull;
// Keep the default SP away from the default .data placement (elf_to_memh.py uses 0x20000).
constexpr std::uint64_t kBootSp = 0x0000'0000'000f'ff00ull;

static bool envFlag(const char *name) {
  const char *v = std::getenv(name);
  if (!v)
    return false;
  // Treat explicit "0" as disabled to support script defaults like PYC_KONATA=${PYC_KONATA:-1}.
  return !(v[0] == '0' && v[1] == '\0');
}

template <unsigned AddrWidth, unsigned DataWidth, std::size_t DepthBytes>
static bool loadMemh(pyc::cpp::pyc_byte_mem<AddrWidth, DataWidth, DepthBytes> &mem, const std::string &path) {
  std::ifstream f(path);
  if (!f.is_open()) {
    std::cerr << "ERROR: failed to open memh: " << path << "\n";
    return false;
  }

  std::uint64_t addr = 0;
  std::string tok;
  while (f >> tok) {
    if (tok.empty())
      continue;
    if (tok[0] == '@') {
      addr = std::stoull(tok.substr(1), nullptr, 16);
      continue;
    }
    unsigned v = std::stoul(tok, nullptr, 16) & 0xFFu;
    mem.pokeByte(static_cast<std::size_t>(addr), static_cast<std::uint8_t>(v));
    addr++;
  }
  return true;
}

static bool runProgram(const char *name, const char *memhPath, std::uint64_t bootPc, std::optional<std::uint32_t> expectedMem100,
                       std::optional<std::uint64_t> expectedA0, std::optional<std::uint32_t> expectedExitCode = std::nullopt) {
  pyc::gen::linx_cpu_pyc dut{};
  if (!loadMemh(dut.imem, memhPath))
    return false;
  if (!loadMemh(dut.dmem, memhPath))
    return false;

  dut.boot_pc = Wire<64>(bootPc);
  std::uint64_t bootSp = kBootSp;
  if (const char *env = std::getenv("PYC_BOOT_SP")) {
    bootSp = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
  }
  dut.boot_sp = Wire<64>(bootSp);
  dut.irq = Wire<1>(0);
  dut.irq_vector = Wire<64>(0);

  Testbench<pyc::gen::linx_cpu_pyc> tb(dut);

  const bool trace_log = (std::getenv("PYC_TRACE") != nullptr);
  const bool trace_vcd = (std::getenv("PYC_VCD") != nullptr);
  const bool trace_konata = envFlag("PYC_KONATA");
  const char *commit_trace_path = std::getenv("PYC_COMMIT_TRACE");
  std::filesystem::path out_dir{};
  if (trace_log || trace_vcd || trace_konata) {
    const char *trace_dir_env = std::getenv("PYC_TRACE_DIR");
    out_dir = trace_dir_env ? std::filesystem::path(trace_dir_env) : std::filesystem::path("examples/generated/linx_cpu_pyc");
    std::filesystem::create_directories(out_dir);

    if (trace_log) {
      tb.enableLog((out_dir / (std::string("tb_linx_cpu_pyc_cpp_") + name + ".log")).string());
      tb.log() << "tb_linx_cpu_pyc(C++): memh=" << memhPath << " boot_pc=0x" << std::hex << bootPc << std::dec << "\n";
    }

    if (trace_vcd) {
      tb.enableVcd((out_dir / (std::string("tb_linx_cpu_pyc_cpp_") + name + ".vcd")).string(), /*top=*/"tb_linx_cpu_pyc_cpp");
      tb.vcdTrace(dut.clk, "clk");
      tb.vcdTrace(dut.rst, "rst");
      tb.vcdTrace(dut.boot_pc, "boot_pc");
      tb.vcdTrace(dut.boot_sp, "boot_sp");
      tb.vcdTrace(dut.irq, "irq");
      tb.vcdTrace(dut.irq_vector, "irq_vector");
      tb.vcdTrace(dut.halted, "halted");
      tb.vcdTrace(dut.exit_code, "exit_code");
      tb.vcdTrace(dut.uart_valid, "uart_valid");
      tb.vcdTrace(dut.uart_byte, "uart_byte");
      tb.vcdTrace(dut.pc, "pc");
      tb.vcdTrace(dut.stage, "stage");
      tb.vcdTrace(dut.cycles, "cycles");
      tb.vcdTrace(dut.if_window, "if_window");
      tb.vcdTrace(dut.wb0_valid, "wb0_valid");
      tb.vcdTrace(dut.wb1_valid, "wb1_valid");
      tb.vcdTrace(dut.wb0_pc, "wb0_pc");
      tb.vcdTrace(dut.wb1_pc, "wb1_pc");
      tb.vcdTrace(dut.wb0_op, "wb0_op");
      tb.vcdTrace(dut.wb1_op, "wb1_op");
      tb.vcdTrace(dut.wb_op, "wb_op");
      tb.vcdTrace(dut.wb_regdst, "wb_regdst");
      tb.vcdTrace(dut.wb_value, "wb_value");
      tb.vcdTrace(dut.commit_cond, "commit_cond");
      tb.vcdTrace(dut.commit_tgt, "commit_tgt");
      tb.vcdTrace(dut.a0, "a0");
      tb.vcdTrace(dut.a1, "a1");
      tb.vcdTrace(dut.ra, "ra");
      tb.vcdTrace(dut.sp, "sp");
    }
  }

  std::ofstream commit_trace{};
  std::uint64_t commit_idx = 0;
  if (commit_trace_path && commit_trace_path[0] != '\0') {
    std::filesystem::path p(commit_trace_path);
    if (p.has_parent_path()) {
      std::filesystem::create_directories(p.parent_path());
    }
    commit_trace.open(p, std::ios::out | std::ios::trunc);
    if (!commit_trace.is_open()) {
      std::cerr << "WARN: failed to open commit trace output: " << p << "\n";
    }
  }

  auto maskInsn = [&](std::uint64_t raw, std::uint8_t len) -> std::uint64_t {
    switch (len) {
    case 2:
      return raw & 0xFFFFu;
    case 4:
      return raw & 0xFFFF'FFFFu;
    case 6:
      return raw & 0xFFFF'FFFF'FFFFu;
    default:
      return raw;
    }
  };

  auto emitCommit = [&](bool valid,
                        std::uint64_t pc,
                        std::uint64_t insn_raw,
                        std::uint8_t len,
                        bool wb_valid,
                        std::uint32_t wb_rd,
                        std::uint64_t wb_data,
                        bool mem_valid,
                        std::uint64_t mem_addr,
                        std::uint64_t mem_wdata,
                        std::uint64_t mem_rdata,
                        std::uint64_t mem_size,
                        bool trap_valid,
                        std::uint32_t trap_cause,
                        std::uint64_t next_pc) {
    if (!commit_trace.is_open() || !valid)
      return;
    const std::uint64_t insn = maskInsn(insn_raw, len);
    commit_trace << "{"
                 << "\"cycle\":" << commit_idx++ << ","
                 << "\"pc\":" << pc << ","
                 << "\"insn\":" << insn << ","
                 << "\"wb_valid\":" << (wb_valid ? 1 : 0) << ","
                 << "\"wb_rd\":" << wb_rd << ","
                 << "\"wb_data\":" << wb_data << ","
                 << "\"mem_valid\":" << (mem_valid ? 1 : 0) << ","
                 << "\"mem_addr\":" << mem_addr << ","
                 << "\"mem_wdata\":" << mem_wdata << ","
                 << "\"mem_rdata\":" << mem_rdata << ","
                 << "\"mem_size\":" << mem_size << ","
                 << "\"trap_valid\":" << (trap_valid ? 1 : 0) << ","
                 << "\"trap_cause\":" << trap_cause << ","
                 << "\"next_pc\":" << next_pc
                 << "}\n";
  };

  tb.addClock(dut.clk, /*halfPeriodSteps=*/1);
  tb.reset(dut.rst, /*cyclesAsserted=*/2, /*cyclesDeasserted=*/1);

  pyc::cpp::KonataWriter konata{};
  if (trace_konata) {
    std::uint64_t start = dut.cycles.value();
    if (!konata.open(out_dir / (std::string("tb_linx_cpu_pyc_cpp_") + name + ".konata"), start)) {
      std::cerr << "WARN: failed to open konata trace output under " << out_dir << "\n";
    }
  }

  std::uint64_t insnCount = 0;
  std::uint64_t maxCycles = 200000;
  if (const char *env = std::getenv("PYC_MAX_CYCLES")) {
    maxCycles = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
  }

  struct PipeSlot {
    bool valid = false;
    std::uint64_t pc = 0;
    std::uint64_t id = 0;
  };

  struct LanePipe {
    PipeSlot st_if{};
    PipeSlot st_id{};
    PipeSlot st_ex{};
    PipeSlot st_mem{};
    PipeSlot st_wb{};
  };

  LanePipe prev[2]{};
  std::uint64_t nextId = 1;

  auto allocId = [&](std::uint64_t pc, int lane) -> std::uint64_t {
    const std::uint64_t id = nextId++;
    if (konata.isOpen()) {
      // Kanata log: all subsequent commands (L/S/E/R/W) reference INSN_ID_IN_FILE
      // (the first field after 'I'), which must be unique in the log.
      konata.insn(/*fileId=*/id, /*simId=*/pc, /*threadId=*/0);
      std::ostringstream ss;
      ss << "pc=0x" << std::hex << pc << " lane=" << std::dec << lane;
      konata.label(id, /*type=*/0, ss.str());
    }
    return id;
  };

  auto assignSlot = [&](PipeSlot &dst, bool valid, std::uint64_t pc, const PipeSlot &prevSame, const PipeSlot *prevFrom, bool allowFrom,
                        int lane) {
    dst.valid = valid;
    dst.pc = pc;
    dst.id = 0;
    if (!valid)
      return;
    if (prevSame.valid && prevSame.pc == pc) {
      dst.id = prevSame.id;
      return;
    }
    if (allowFrom && prevFrom && prevFrom->valid && prevFrom->pc == pc) {
      dst.id = prevFrom->id;
      return;
    }
    dst.id = allocId(pc, lane);
  };

  auto stageUpdate = [&](const PipeSlot &prevS, const PipeSlot &curS, int lane, const char *stage, bool retireOnEnd) {
    if (!konata.isOpen())
      return;
    if (prevS.valid && (!curS.valid || curS.id != prevS.id)) {
      konata.stageEnd(prevS.id, lane, stage);
      if (retireOnEnd)
        konata.retire(prevS.id, /*retireId=*/prevS.id, /*type=*/0);
    }
    if (curS.valid && (!prevS.valid || curS.id != prevS.id)) {
      konata.stageStart(curS.id, lane, stage);
    }
  };

  for (std::uint64_t i = 0; i < maxCycles; i++) {
    if (konata.isOpen())
      konata.atCycle(dut.cycles.value());

    // Update Konata pipeview from exported stage signals.
    LanePipe cur[2]{};
    for (int lane = 0; lane < 2; lane++) {
      const bool if_v = (lane == 0) ? dut.if0_valid.toBool() : dut.if1_valid.toBool();
      const std::uint64_t if_pc = (lane == 0) ? dut.if0_pc.value() : dut.if1_pc.value();
      const bool id_v = (lane == 0) ? dut.ifid0_valid.toBool() : dut.ifid1_valid.toBool();
      const std::uint64_t id_pc = (lane == 0) ? dut.ifid0_pc.value() : dut.ifid1_pc.value();
      const bool ex_v = (lane == 0) ? dut.idex0_valid.toBool() : dut.idex1_valid.toBool();
      const std::uint64_t ex_pc = (lane == 0) ? dut.idex0_pc.value() : dut.idex1_pc.value();
      const bool mem_v = (lane == 0) ? dut.exmem0_valid.toBool() : dut.exmem1_valid.toBool();
      const std::uint64_t mem_pc = (lane == 0) ? dut.exmem0_pc.value() : dut.exmem1_pc.value();
      const bool wb_v = (lane == 0) ? dut.wb0_valid.toBool() : dut.wb1_valid.toBool();
      const std::uint64_t wb_pc = (lane == 0) ? dut.wb0_pc.value() : dut.wb1_pc.value();

      assignSlot(cur[lane].st_if, if_v, if_pc, prev[lane].st_if, /*prevFrom=*/nullptr, /*allowFrom=*/false, lane);
      assignSlot(cur[lane].st_id, id_v, id_pc, prev[lane].st_id, &prev[lane].st_if, /*allowFrom=*/true, lane);
      assignSlot(cur[lane].st_ex, ex_v, ex_pc, prev[lane].st_ex, &prev[lane].st_id, /*allowFrom=*/true, lane);
      assignSlot(cur[lane].st_mem, mem_v, mem_pc, prev[lane].st_mem, &prev[lane].st_ex, /*allowFrom=*/true, lane);
      assignSlot(cur[lane].st_wb, wb_v, wb_pc, prev[lane].st_wb, &prev[lane].st_mem, /*allowFrom=*/true, lane);

      stageUpdate(prev[lane].st_if, cur[lane].st_if, lane, "IF", /*retireOnEnd=*/false);
      stageUpdate(prev[lane].st_id, cur[lane].st_id, lane, "ID", /*retireOnEnd=*/false);
      stageUpdate(prev[lane].st_ex, cur[lane].st_ex, lane, "EX", /*retireOnEnd=*/false);
      stageUpdate(prev[lane].st_mem, cur[lane].st_mem, lane, "MEM", /*retireOnEnd=*/false);
      stageUpdate(prev[lane].st_wb, cur[lane].st_wb, lane, "WB", /*retireOnEnd=*/true);

      // Attach op label on WB stage entry (optional).
      if (konata.isOpen() && cur[lane].st_wb.valid && (!prev[lane].st_wb.valid || cur[lane].st_wb.id != prev[lane].st_wb.id)) {
        const std::uint64_t op = (lane == 0) ? dut.wb0_op.value() : dut.wb1_op.value();
        std::ostringstream ss;
        ss << "wb op=" << std::dec << op;
        konata.label(cur[lane].st_wb.id, /*type=*/1, ss.str());
      }

      prev[lane] = cur[lane];
    }

    if (dut.uart_valid.toBool()) {
      const char c = static_cast<char>(dut.uart_byte.value() & 0xFFu);
      if (trace_log) {
        tb.log() << c;
      }
      std::cout << c << std::flush;
    }
    if (trace_log && dut.stage.value() == 4 && !dut.halted.toBool()) { // ST_WB
      insnCount++;
      tb.log() << "[wb #" << std::dec << insnCount << "] pc=0x" << std::hex << dut.pc.value()
               << " win=0x" << dut.if_window.value() << " op=" << std::dec << dut.wb_op.value()
               << " regdst=" << dut.wb_regdst.value() << " value=0x" << std::hex << dut.wb_value.value()
               << " a0=0x" << dut.a0.value() << " a1=0x" << dut.a1.value() << " ra=0x" << dut.ra.value()
               << " sp=0x" << dut.sp.value() << " br_kind=" << std::dec << dut.br_kind.value()
               << " commit_cond=" << dut.commit_cond.value() << " commit_tgt=0x" << std::hex << dut.commit_tgt.value()
               << std::dec << "\n";
    }

    emitCommit(dut.commit0_valid.toBool(),
               dut.commit0_pc.value(),
               dut.commit0_insn_raw.value(),
               static_cast<std::uint8_t>(dut.commit0_len.value() & 0xFFu),
               dut.commit0_wb_valid.toBool(),
               static_cast<std::uint32_t>(dut.commit0_wb_rd.value()),
               dut.commit0_wb_data.value(),
               dut.commit0_mem_valid.toBool(),
               dut.commit0_mem_addr.value(),
               dut.commit0_mem_wdata.value(),
               dut.commit0_mem_rdata.value(),
               dut.commit0_mem_size.value(),
               dut.commit0_trap_valid.toBool(),
               static_cast<std::uint32_t>(dut.commit0_trap_cause.value()),
               dut.commit0_next_pc.value());

    emitCommit(dut.commit1_valid.toBool(),
               dut.commit1_pc.value(),
               dut.commit1_insn_raw.value(),
               static_cast<std::uint8_t>(dut.commit1_len.value() & 0xFFu),
               dut.commit1_wb_valid.toBool(),
               static_cast<std::uint32_t>(dut.commit1_wb_rd.value()),
               dut.commit1_wb_data.value(),
               dut.commit1_mem_valid.toBool(),
               dut.commit1_mem_addr.value(),
               dut.commit1_mem_wdata.value(),
               dut.commit1_mem_rdata.value(),
               dut.commit1_mem_size.value(),
               dut.commit1_trap_valid.toBool(),
               static_cast<std::uint32_t>(dut.commit1_trap_cause.value()),
               dut.commit1_next_pc.value());

    tb.runCycles(1);
    if (dut.halted.toBool())
      break;
  }
  if (!dut.halted.toBool()) {
    std::cerr << "FAIL " << name << ": did not halt after " << std::dec << maxCycles << " cycles (pc=0x" << std::hex
              << dut.pc.value() << ")\n";
    return false;
  }

  const bool haltedInvalid =
      (dut.wb0_valid.toBool() && dut.wb0_op.value() == 0) || (dut.wb1_valid.toBool() && dut.wb1_op.value() == 0);
  if (haltedInvalid) {
    std::cerr << "FAIL " << name << ": halted due to OP_INVALID"
              << " (wb0: valid=" << dut.wb0_valid.toBool() << " pc=0x" << std::hex << dut.wb0_pc.value()
              << " op=" << std::dec << dut.wb0_op.value() << ", wb1: valid=" << dut.wb1_valid.toBool()
              << " pc=0x" << std::hex << dut.wb1_pc.value() << " op=" << std::dec << dut.wb1_op.value()
              << ")\n";
    return false;
  }

  if (expectedExitCode.has_value()) {
    std::uint32_t got = static_cast<std::uint32_t>(dut.exit_code.value());
    if (got != *expectedExitCode) {
      std::cerr << "FAIL " << name << ": exit_code=0x" << std::hex << got << " expected 0x" << *expectedExitCode
                << std::dec << "\n";
      return false;
    }
  }

  if (expectedA0.has_value()) {
    std::uint64_t got = dut.a0.value();
    if (got != *expectedA0) {
      std::uint32_t mem0 = dut.dmem.peek32(0x0);
      std::uint32_t mem20000 = dut.dmem.peek32(0x20000);
      std::cerr << "FAIL " << name << ": a0=0x" << std::hex << got << " expected 0x" << *expectedA0
                << " (pc=0x" << dut.pc.value() << " a1=0x" << dut.a1.value() << " ra=0x" << dut.ra.value()
                 << " sp=0x" << dut.sp.value() << " mem[0]=0x" << mem0 << " mem[0x20000]=0x" << mem20000 << ")"
                << std::dec << "\n";
      return false;
    }
  }

  std::uint32_t got = dut.dmem.peek32(0x100);
  if (expectedMem100.has_value()) {
    if (got != *expectedMem100) {
      std::cerr << "FAIL " << name << ": mem[0x100]=0x" << std::hex << got << " expected 0x" << *expectedMem100
                << std::dec << "\n";
      return false;
    }
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << ")\n";
  } else {
    std::cout << "ok: " << name << " (cycles=" << std::dec << dut.cycles.value() << " mem[0x100]=0x" << std::hex << got
              << std::dec << ")\n";
  }
  return true;
}

} // namespace

int main(int argc, char **argv) {
  if (argc >= 2) {
    const char *memh = argv[1];
    std::optional<std::uint32_t> expectedMem100{};
    std::optional<std::uint64_t> expectedA0{};
    if (argc >= 3)
      expectedMem100 = static_cast<std::uint32_t>(std::stoul(argv[2], nullptr, 0));
    if (argc >= 4)
      expectedA0 = static_cast<std::uint64_t>(std::stoull(argv[3], nullptr, 0));
    std::uint64_t bootPc = kBootPc;
    if (const char *env = std::getenv("PYC_BOOT_PC")) {
      bootPc = static_cast<std::uint64_t>(std::stoull(env, nullptr, 0));
    }
    std::optional<std::uint32_t> expectedExit{};
    if (const char *env = std::getenv("PYC_EXPECT_EXIT")) {
      expectedExit = static_cast<std::uint32_t>(std::stoul(env, nullptr, 0));
    }
    return runProgram("program", memh, bootPc, expectedMem100, expectedA0, expectedExit) ? 0 : 1;
  }

  // Default regression tests (memh fixtures checked into the repo).
  if (!runProgram("test_csel_fixed", "examples/linx_cpu/programs/test_csel_fixed.memh", kBootPc, /*expectedMem100=*/100u, /*expectedA0=*/{}))
    return 1;
  if (!runProgram("test_or", "examples/linx_cpu/programs/test_or.memh", kBootPc, /*expectedMem100=*/0x0000FF00u, /*expectedA0=*/{}))
    return 1;

  if (!runProgram("test_branch2", "examples/linx_cpu/programs/test_branch2.memh", /*bootPc=*/kBootPc + 0x0a, /*expectedMem100=*/{}, /*expectedA0=*/8u))
    return 1;
  if (!runProgram("test_call_simple", "examples/linx_cpu/programs/test_call_simple.memh", /*bootPc=*/kBootPc + 0x1c, /*expectedMem100=*/{}, /*expectedA0=*/42u))
    return 1;
  if (!runProgram("test_jump", "examples/linx_cpu/programs/test_jump.memh", kBootPc, /*expectedMem100=*/{}, /*expectedA0=*/42u))
    return 1;
  if (!runProgram("test_pcrel", "examples/linx_cpu/programs/test_pcrel.memh", kBootPc, /*expectedMem100=*/{}, /*expectedA0=*/43u))
    return 1;
  return 0;
}
